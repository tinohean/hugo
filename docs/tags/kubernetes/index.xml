<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kubernetes on 半岛无风</title>
    <link>http://tinohean.top/tags/kubernetes/</link>
    <description>Recent content in kubernetes on 半岛无风</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Feb 2020 22:52:33 +0800</lastBuildDate><atom:link href="http://tinohean.top/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubeadm部署kubernetes集群</title>
      <link>http://tinohean.top/p/kubeadm%E9%83%A8%E7%BD%B2kubernetes%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Fri, 14 Feb 2020 22:52:33 +0800</pubDate>
      
      <guid>http://tinohean.top/p/kubeadm%E9%83%A8%E7%BD%B2kubernetes%E9%9B%86%E7%BE%A4/</guid>
      <description>Kubeadm部署kubernetes集群 前期准备 节点规划    主机名 角色 ip 配置 系统版本     k8s-master-01 master 172.21.0.3 4C8G Ubuntu 16.04.1 LTS   k8s-master-02 master 172.21.0.4 4C8G Ubuntu 16.04.1 LTS   k8s-master-03 master 172.21.0.5 4C8G Ubuntu 16.04.1 LTS   k8s-node-01 node 172.21.0.6 4C8G Ubuntu 16.04.1 LTS   k8s-node-02 node 172.21.0.7 4C8G Ubuntu 16.04.1 LTS   k8s-apiserver LB apiserver.k8s.local nginx实现的localproxy     环境配置 所有服务器都需要进行基本环境配置，比如关闭防火墙，关闭swap等</description>
    </item>
    
    <item>
      <title>部署策略及容器化实现</title>
      <link>http://tinohean.top/p/%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 21 Sep 2019 23:11:56 +0800</pubDate>
      
      <guid>http://tinohean.top/p/%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E7%8E%B0/</guid>
      <description>应用容器化改造的设计原则及模式 蓝绿发布 kubernetes实现 金丝雀发布 kubernetes实现 参考文档  https://harness.io/blog/continuous-verification/blue-green-canary-deployment-strategies/ https://medium.com/tech-at-wildlife-studios/canary-deployment-in-kubernetes-how-to-use-the-pattern-b2e9c40d085d https://kubernetes.io/zh/docs/concepts/cluster-administration/manage-deployment/ https://www.ianlewis.org/en/bluegreen-deployments-kubernetes  </description>
    </item>
    
    <item>
      <title>CMD和ENTRYPOINT的配置比对详解</title>
      <link>http://tinohean.top/p/cmd%E5%92%8Centrypoint%E7%9A%84%E9%85%8D%E7%BD%AE%E6%AF%94%E5%AF%B9%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 02 Sep 2019 11:47:40 +0800</pubDate>
      
      <guid>http://tinohean.top/p/cmd%E5%92%8Centrypoint%E7%9A%84%E9%85%8D%E7%BD%AE%E6%AF%94%E5%AF%B9%E8%AF%A6%E8%A7%A3/</guid>
      <description>CMD和ENTRYPOINT的配置比对详解 概述 Dockerfile的语法包括CMD和Entrypoint两种格式都可以配置用于容器内主进程的启动，两者的语义并不是很合适。新上手很容易搞不清楚两者之间的区别和关系，在不同的配置搭配下会产生怎样的运行效果也没有一个条理清晰的思路。
同样的，k8s也有一套类似的配置语法：command和args。那么k8s的语法中两者又是怎样的搭配关系，它们跟docker语法又是怎样的映射关系呢？
本文将进行详情分析。
Docker中CMD和ENTRYPOINT的区别 两种运行模式 不管是CMD还是ENTRYPOINT配置，实际都是有两种模式：SHELL模式，EXEC模式。
SHELL模式 命令是运行在命令解析器中的，比如linux的/bin/sh -c, windows的cmd /S /C。
此时容器中的init进程（PID为1）是/bin/sh -c &amp;lt;process&amp;gt;，而不是容器的可执行程序，&amp;lt;process&amp;gt;只做为/bin/sh -c的子进程存在。
Linux内核机制下，PID为1的进程（通常是init)有区别与其他进程的地方：
 PID为1的进程死掉后，其他所有进程都会被KILL信号杀死（也就是强制退出） 当某父进程死掉后，PID为1的进程会自动继承为其子进程的父进程。 内核不会为PID为1的进程自动注册信号处理程序。PID为1的进程无法接受SIGTERM和SIGINT这类信号，只能SIGKILL强制退出。  因此，我们无法通过docker stop &amp;lt;container&amp;gt;进行优雅退出，因为kubernetes和docker只能发送SIGKILL信号给PID为1的进程，而此时PID为1的/bin/sh -c 没办法传递信号给&amp;lt;process&amp;gt;，只会通过SIGKILL强制退出。而强制退出带来的后果可能是写入中断，数据异常等。
当然也有解决办法,比如共享进程的namespace，使用专门的init程序，比如tini,supervisor等。最方便的是使用exec命令从shell脚本启动进程，进程会继承PID 1：
# shell模式下，通过exec配置可以接受signalENTRYPOINT exec cmd1 param1语法如下
#单独用CMDCMD command param1 param2#单独用ENTRYPOINTENTROYPOINT command param1 param2#搭配使用只会执行ENTRYPOINT，因此CMD此时配置没什么意义以上的运行效果是一样的。
EXEC模式 主进程就是&amp;lt;process&amp;gt;,所以不经过shell默认的环境变量解释替换过程。由此带来的问题是，类似cd ~和cd $HOME是无效的，因为此时是docker负责进行变量解析。
这种模式下配置是被解析成json array的，因此必须全部使用双引号！
语法如下
# 单独用CMDCMD [&amp;#34;executable&amp;#34;, &amp;#34;param1&amp;#34;, &amp;#34;param2&amp;#34;]# 单独用ENTRYPOINTENTRYPOINT [&amp;#34;executable&amp;#34;, &amp;#34;param1&amp;#34;, &amp;#34;param2&amp;#34;]# 搭配使用1ENTRYPOINT [&amp;#34;executable&amp;#34;]CMD [&amp;#34;param1&amp;#34;, &amp;#34;param2&amp;#34;]# 搭配使用2ENTRYPOINT [&amp;#34;executable&amp;#34;, &amp;#34;param1&amp;#34;]CMD [&amp;#34;param2&amp;#34;]以上语法的运行效果也是一样的。
配置 简单来说，CMD和ENTRYPOINT的作用都一样，都是用于容器的主进程启动。唯一不同的是，当配置了ENTRYPOINT时，CMD只作为ENTRYPOINT的命令参数存在。两者也可以单独存在。
因此，配置其实有三种方式</description>
    </item>
    
    <item>
      <title>应用容器化改造的设计原则及模式</title>
      <link>http://tinohean.top/p/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8C%96%E6%94%B9%E9%80%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%8F%8A%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 15 May 2019 19:24:26 +0800</pubDate>
      
      <guid>http://tinohean.top/p/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8C%96%E6%94%B9%E9%80%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%8F%8A%E6%A8%A1%E5%BC%8F/</guid>
      <description>应用容器化改造的设计原则及模式 前言 传统应用在应对流量突发等情况时需要一个完善的紧急响应机制，比如自动弹性伸缩。但由于软硬件限制，自动弹性伸缩在物理机上实现复杂。
尽管kubernetes学习路线陡峭，复杂度高，但是考虑到成本和效率，推进应用进行容器化改造是一个收益率很高的事情。
在经历数次微博流量飙升导致深夜紧急手动扩容后，我终于下定决心将两个核心应用迁移到容器上了。
当然，并不是所有应用都适合容器化，传统应用进行容器化也需要进行一些适配性地改造。
本文是我调研容器化的改造设计原则及模式的成果。
设计原则 单一职责原则  SINGLE CONCERN PRINCIPLE 
字面意识就是只做一件事，并把它做好。
根据Docker最佳实践解释，一个容器应当仅包含一个进程。 此处的进程是指具有唯一父进程且可能拥有多个子进程的单个软件。
目的是为了增加镜像的可复用性和可移植性，单父进程带来的相同的生命周期和状态也便于kubernetes管理。
生产环境中不可避免会遇到一些例外。一些复杂的场景需要多个进程协调，此时可以使用边车模式（sidecar)解决。比如tomcat日志归集。
高可观测性原则  HIGH OBSERVABILITY PRINCIPLE 
容器的设计决定了它的不便观测性，一个运行中的容器对管理者来说是一个黑盒状态，因此不能像虚拟机一样随时TTY登陆查看容器内部的状态，包括进程的日志，进程的启动等。
那么探针的设计就显得格外重要了。通过探针，kubernetes可以知晓容器的存活，服务就绪状态等。
除了探针外，我们还需要设计日志接口和监控接口来对接Fluentd,Prometheus等工具进行日常操作，比如日志归集，指标监控等。
总结下来，容器化的应用需要做好三类接口设计，以便于通过平台进行状态管理和维护：
 探针 日志 监控  生命周期符合性原则  LIFE-CYCLE CONFORMANCE PRINCIPLE 
kubernetes这类平台为了方便管理容器的生命周期，会产生各种各样的events。这类事件主要是通过Linux信号进行传递,比如SIGTERM和SIGKILL。
因此，在设计容器应用的时候，开发者需要对这类事件做出恰当的反应逻辑规划并保持符合性。比如进程能接受SIGTERM信号后优雅退出。
镜像不变性原则  IMAGE IMMUTABILITY PRINCIPLE  镜像作为容器的运行基本,应该保持不变的。这样才有可能进行回滚和滚动发布，从而推动自动化。
这个原则意味着什么呢？每次变更应该是重新构建一个镜像并应用于所有环境。
对于一些不同的环境需求，比如开发环境，测试环境，可以通过外部存储runtime数据来进行区分。
进程可弃型原则  PROCESS DISPOSABILITY PRINCIPLE  基于上面的镜像不变性原则，每次应用变更应该是重新构建，所以容器必须是随时可以销毁的。
无状态的应用是最适合容器化的，当然有状态的应用也可以通过外部持久卷的方式存储运行时数据来实现这一原则。
自包含原则  SELF-CONTAINMENT PRINCIPLE  容器作为一个黑盒环境，除了Linux内核外，应该不依赖于任何外部依赖。镜像应该打包了所有应用运行所需的库文件，语言环境等。
运行时限制原则  RUNTIME CONFINEMENT PRINCIPLE  容器运行时所需的任何硬件资源，比如cpu,mem等，应该做好配额管理，包括使用量声明和实际使用限制。 这个原则主要是为了便于资源调度，弹性伸缩等。</description>
    </item>
    
  </channel>
</rss>
